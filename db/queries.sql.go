// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createBeer = `-- name: CreateBeer :one
INSERT INTO bdb_beers (
	brewery_id, type_id, name, description, abv, ibu
) VALUES (
	$1, $2, $3, $4, $5, $6
) RETURNING beer_id, created_at
`

type CreateBeerParams struct {
	BreweryID   int32   `json:"brewery_id"`
	TypeID      int32   `json:"type_id"`
	Name        string  `json:"name"`
	Description string  `json:"description"`
	Abv         float64 `json:"abv"`
	Ibu         int32   `json:"ibu"`
}

type CreateBeerRow struct {
	BeerID    int32     `json:"beer_id"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateBeer(ctx context.Context, arg CreateBeerParams) (CreateBeerRow, error) {
	row := q.queryRow(ctx, q.createBeerStmt, createBeer,
		arg.BreweryID,
		arg.TypeID,
		arg.Name,
		arg.Description,
		arg.Abv,
		arg.Ibu,
	)
	var i CreateBeerRow
	err := row.Scan(&i.BeerID, &i.CreatedAt)
	return i, err
}

const createBrewery = `-- name: CreateBrewery :one
INSERT INTO bdb_breweries (
	name, url, description, address, city, state, country_id, phone, url
) VALUES (
	$1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING brewery_id, created_at
`

type CreateBreweryParams struct {
	Name        string         `json:"name"`
	Url         sql.NullString `json:"url"`
	Description string         `json:"description"`
	Address     sql.NullString `json:"address"`
	City        sql.NullString `json:"city"`
	State       sql.NullString `json:"state"`
	CountryID   int32          `json:"country_id"`
	Phone       sql.NullString `json:"phone"`
	Url_2       sql.NullString `json:"url_2"`
}

type CreateBreweryRow struct {
	BreweryID int32     `json:"brewery_id"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateBrewery(ctx context.Context, arg CreateBreweryParams) (CreateBreweryRow, error) {
	row := q.queryRow(ctx, q.createBreweryStmt, createBrewery,
		arg.Name,
		arg.Url,
		arg.Description,
		arg.Address,
		arg.City,
		arg.State,
		arg.CountryID,
		arg.Phone,
		arg.Url_2,
	)
	var i CreateBreweryRow
	err := row.Scan(&i.BreweryID, &i.CreatedAt)
	return i, err
}

const createType = `-- name: CreateType :one
INSERT INTO bdb_types (
	name,
	description
) VALUES (
	$1, $2
) RETURNING type_id, created_at
`

type CreateTypeParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

type CreateTypeRow struct {
	TypeID    int32     `json:"type_id"`
	CreatedAt time.Time `json:"created_at"`
}

func (q *Queries) CreateType(ctx context.Context, arg CreateTypeParams) (CreateTypeRow, error) {
	row := q.queryRow(ctx, q.createTypeStmt, createType, arg.Name, arg.Description)
	var i CreateTypeRow
	err := row.Scan(&i.TypeID, &i.CreatedAt)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO bdb_users (
	first_name, last_name, username, email, hash
) VALUES (
	$1, $2, $3, $4, hash($5)
) RETURNING user_id, username, token, token_expires
`

type CreateUserParams struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Username  string `json:"username"`
	Email     string `json:"email"`
	Password  string `json:"password"`
}

type CreateUserRow struct {
	UserID       int32     `json:"user_id"`
	Username     string    `json:"username"`
	Token        string    `json:"token"`
	TokenExpires time.Time `json:"token_expires"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.Email,
		arg.Password,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Token,
		&i.TokenExpires,
	)
	return i, err
}

const generateNewToken = `-- name: GenerateNewToken :one
UPDATE bdb_users set
	token = DEFAULT,
	token_expires = DEFAULT
WHERE
	token = $1
RETURNING token, token_expires
`

type GenerateNewTokenRow struct {
	Token        string    `json:"token"`
	TokenExpires time.Time `json:"token_expires"`
}

func (q *Queries) GenerateNewToken(ctx context.Context, token string) (GenerateNewTokenRow, error) {
	row := q.queryRow(ctx, q.generateNewTokenStmt, generateNewToken, token)
	var i GenerateNewTokenRow
	err := row.Scan(&i.Token, &i.TokenExpires)
	return i, err
}

const getAllBeers = `-- name: GetAllBeers :many
SELECT beer_id, brewery_id, type_id, created_at, updated_at, name, description, abv, ibu FROM bdb_beers
ORDER BY created_at DESC
`

func (q *Queries) GetAllBeers(ctx context.Context) ([]BdbBeer, error) {
	rows, err := q.query(ctx, q.getAllBeersStmt, getAllBeers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BdbBeer
	for rows.Next() {
		var i BdbBeer
		if err := rows.Scan(
			&i.BeerID,
			&i.BreweryID,
			&i.TypeID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Abv,
			&i.Ibu,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeersByBrewery = `-- name: GetBeersByBrewery :many
SELECT beer_id, brewery_id, type_id, created_at, updated_at, name, description, abv, ibu FROM bdb_beers
WHERE brewery_id = $1
`

func (q *Queries) GetBeersByBrewery(ctx context.Context, breweryID int32) ([]BdbBeer, error) {
	rows, err := q.query(ctx, q.getBeersByBreweryStmt, getBeersByBrewery, breweryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BdbBeer
	for rows.Next() {
		var i BdbBeer
		if err := rows.Scan(
			&i.BeerID,
			&i.BreweryID,
			&i.TypeID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Abv,
			&i.Ibu,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentBeers = `-- name: GetRecentBeers :many
SELECT beer_id, brewery_id, type_id, created_at, updated_at, name, description, abv, ibu FROM bdb_beers
WHERE created_at >= $1
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
`

type GetRecentBeersParams struct {
	CreatedAt time.Time `json:"created_at"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) GetRecentBeers(ctx context.Context, arg GetRecentBeersParams) ([]BdbBeer, error) {
	rows, err := q.query(ctx, q.getRecentBeersStmt, getRecentBeers, arg.CreatedAt, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BdbBeer
	for rows.Next() {
		var i BdbBeer
		if err := rows.Scan(
			&i.BeerID,
			&i.BreweryID,
			&i.TypeID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.Abv,
			&i.Ibu,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByToken = `-- name: GetUserByToken :one
SELECT user_id, created_at, updated_at, active, first_name, last_name, username, hash, email, token, token_expires FROM bdb_users
WHERE token = $1 LIMIT 1
`

func (q *Queries) GetUserByToken(ctx context.Context, token string) (BdbUser, error) {
	row := q.queryRow(ctx, q.getUserByTokenStmt, getUserByToken, token)
	var i BdbUser
	err := row.Scan(
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Active,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Hash,
		&i.Email,
		&i.Token,
		&i.TokenExpires,
	)
	return i, err
}

const login = `-- name: Login :one
SELECT token, token_expires FROM bdb_users
WHERE username = $1 and crypt($2, hash) = hash
`

type LoginParams struct {
	Username string `json:"username"`
	Crypt    string `json:"crypt"`
}

type LoginRow struct {
	Token        string    `json:"token"`
	TokenExpires time.Time `json:"token_expires"`
}

func (q *Queries) Login(ctx context.Context, arg LoginParams) (LoginRow, error) {
	row := q.queryRow(ctx, q.loginStmt, login, arg.Username, arg.Crypt)
	var i LoginRow
	err := row.Scan(&i.Token, &i.TokenExpires)
	return i, err
}

const searchBeers = `-- name: SearchBeers :many
SELECT beer_id, brewery_id, name,
	similarity(description, $1) as desc_similarity,
	ts_headline('english', description, q, 'StartSel = <b>, StopSel = </b>') as headline
FROM bdb_beers, to_tsquery($1) q
WHERE similarity(description, $1) > 0.0
	order by similarity DESC
`

type SearchBeersRow struct {
	BeerID         int32           `json:"beer_id"`
	BreweryID      int32           `json:"brewery_id"`
	Name           string          `json:"name"`
	DescSimilarity float32         `json:"desc_similarity"`
	Headline       json.RawMessage `json:"headline"`
}

func (q *Queries) SearchBeers(ctx context.Context, similarity string) ([]SearchBeersRow, error) {
	rows, err := q.query(ctx, q.searchBeersStmt, searchBeers, similarity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBeersRow
	for rows.Next() {
		var i SearchBeersRow
		if err := rows.Scan(
			&i.BeerID,
			&i.BreweryID,
			&i.Name,
			&i.DescSimilarity,
			&i.Headline,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
